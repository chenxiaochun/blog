## 什么是并行模式的 React？

在 React18 的一个重要理念，就是希望开发者在实际编码时，能够不用再去过度考虑程序的并发性

并行模式，其实是一套新的、运行于后台的机制，能够在同一时间点准备好多个版本的 UI 渲染

React 团队实现此机制使用的也都是很成熟的技术，比如：队列优先级、多级缓存等。这些实现细节，官方也没有以任何方式公开。虽然不需要了解它的实现细节。但是，并行模式确实改变了 react 的核心渲染机制。因此，从更高维度去对它进行理解，还是非常有意义的

并行模式的关键点就是：渲染过程是可以被中断的。在 react18 之前版本中，一旦开始渲染一个同步更新任务，就不可能被中断，一直等到它被渲染完成才行

在并行模式中，就不是这样渲染了。一个任务可以开始渲染，也可以被中断，稍后可以再继续渲染，甚至有可能被完全丢弃。而且，即使任务被中断了，react 也能保证界面的一致性。那为了做到这一点，
react 会等整个虚拟 dom 都构建完成之后，才去更新真实 dom。基于这种能力，react 就可以在不阻塞主线程的情况下，在后台完成新界面的准备渲染工作。这就意味着，即使在对一个非常大的任务进行
渲染时，界面也能够即时的响应用户操作，以达到流畅的用户体验

还有另一种使用场景是关于状态的可复用性。就是 react 会自动将暂时不可见的部分界面进行移除，待回到之前的界面时，再重复利用之前的状态。比如用户进行 tab 切换时。将来，react 中会增加一个新的叫做`<OffsetScreen />`的组件来实现这种模式。这样就可以在后台提前为用户准备好将要渲染的界面了

总之，并行模式在 react 中是一个非常强大的工具。而且像`Suspense`、`transitions`和服务端流式渲染等新特性都依赖于此。对于 react18 来说，这仅仅是一个开始。基于此，将来还会达成更多的新目标

## 逐步适配并行模式

并行模式是一个 breaking change，开启它之后，会导致组件的行为发生细微的变化

## React18 带来了哪些新特性？

### 自动的批次更新

在之前的版本中，只有在 react 的事件处理器中才会有自动批次更新的机制。现在除了 react 的事件处理器外，react 中的其它地方都可以自动批次更新。例如：`promise`、`setTimeout`、`setInterval`、`setImmediate`、`requestAnimationFrame`等

```js
// Before: 仅仅 react 事件处理器中有自动批次更新的机制
setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // react 将会渲染两次，因为 setCount 和 setFlag 都会触发一次更新
}, 1000);

// After： 在 setTimeout、promise、事件处理器中的更新都会被批量更新
setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // react 最终将只会渲染一次
}, 1000);
```


## 个人对 concurrent 模式的理解

### 现在的问题

首先，在 react18 之前，一个任务一旦开始执行，是不能中断的。它必须从头执行到尾，这个渲染流程大概是这样的：

![](https://image-static.segmentfault.com/128/963/1289637795-a6b27abcc8b62225)


而且我们知道，计算机一般的刷新频率是：60赫兹/秒。因此：

```
1000(毫秒) / 60(赫兹) ≈ 16.7(毫秒)
```

那也就是说，如果一段代码的执行时间超过了 16.7 毫秒，理论上就会发生卡顿。因为浏览器是单线程的，一个任务如果在执行中，其它任务就只能排队等候。而如果这时候正好有用户操作了界面，例如点击文本框输入内容。用户就会真实的感受到卡顿

### 解决方式

对于执行时间比较长的大任务，我们最常用的方式就是把它拆成若干个小任务来执行。React 开发团队也是这么搞的

一个执行时间比较长的大任务，它正常开始执行。当耗时达到 16.7 毫秒的时候（react 内部实现可能不是这个数字，这里仅用来解释概念），判断其是否已经执行完毕？

如果没有执行完毕，会查看是否有更重要的任务需要优先执行。如果有，则暂停之前的低优先级任务，优先执行优先级较高的任务。待高级优先级任务执行完成之后，再继续执行之前的低优先任务。依此类推

那哪些属于优先级比较高的任务呢？例如：动画和用户点击操作。用户期待的就是能够立刻接受到反馈，这些任务如果不优先尽快执行的话，用户立刻就会感受到界面的卡顿。而像网络请求等任务，哪怕稍微延迟一会儿，对用户的感知体验也不会有太大的影响

而为了实现这个机制，react 团队花了至少两年时间重写了其内部的任务调度算法。React 开发团队之所以没有使用浏览器原生的`requestIdleCallback`，就是因为它不够灵活和精确，它只能在浏览器的主线程中执行，而且不能保证在任何时候都能执行

## 参考链接

* https://zh-hans.reactjs.org/blog/2022/03/29/react-v18.html
* https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback
* https://segmentfault.com/a/1190000041112179


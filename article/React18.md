## 什么是并行模式的 React？

在 React18 版本中增加的一个重要理念，就是我们希望开发者在实际开发时，能够不用再去考虑程序的并发性。虽然实现这件事儿，对于 react 这个库的开发者来说，
是一件非常复杂的事情。但我们相信，它对于应用开发者来说，应该是一件非常有用的事情

并行模式，并不是什么新特性。它其实是一套运行于后台的，能够在同一时间点准备好多个版本的 UI 渲染

我们在设计 api 时，就是想能够尽量对开发者隐藏实现细节。作为 react 开发者，只需要尽量关注业务实现，最终的体验由 react 来交付保证

虽然不需要了解它的实现细节。但是，实现并行模式还牵扯改变了 react 的核心渲染模式。因此，从更高维度去对它进行理解，还是非常有意义的

React 并行模式的关键点就是：渲染过程是可以被中断了。在 react18 之前版本中，一旦开始渲染一个同步更新任务，就不可能被中断，一直等到它被渲染完成才行

在并行模式中，就不是这样渲染了。一个任务可以开始渲染，也可以被中断，稍后可以再继续渲染，甚至有可能被完全丢弃。而且，即使任务被中断了，react 也能保证界面的一致性。那为了做到这一点，
react 会等整个虚拟 dom 都构建完成之后，才去更新真实 dom。基于这种能力，react 就可以在不阻塞主线程的情况下，在后台完成新界面的准备渲染工作。这就意味着，即使在对一个非常大的任务进行
渲染时，界面也能够即时的响应用户操作，以达到流畅的用户体验

还有另一种使用场景是关于状态的可复用性。就是 react 会自动将暂时不可见的部分界面进行移除，待回到之前的界面时，再重复利用之前的状态。比如用户进行 tab 切换时。将来，react 中会增加一个新的叫做`<OffsetScreen />`的组件来实现这种模式。这样就可以在后台提前为用户准备好将要渲染的界面了

总之，并行模式在 react 中是一个非常强大的工具。而且像`Suspense`、`transitions`和服务端流式渲染等新特性都依赖于此。对于 react18 来说，这仅仅是一个开始。基于此，将来还会达成更多的新目标

## 逐步适配并行模式

## 我对 concurrent 模式的理解

### 问题是什么？

首先，在 react18 之前，一个任务一旦开始执行，是不能中断的。它必须从头执行到尾，这个渲染流程大概是这样的：

```
1. 组件发生变动
2. 生成虚拟 dom 树
3. 与旧的 dom 树进行对比
4. 生成新的虚拟 dom 树
5. 绘制真实的 dom 树
```

还有一点我们需要知道，计算机一般的刷新频率是：60赫兹/秒

```
1000(毫秒) / 60(赫兹) ≈ 16.7(毫秒)
```

那也就是说，如果一段代码的执行时间超过了 16.7 毫秒，理论上就会发生卡顿。因为浏览器是单线程，一个任务如果在执行中，其它任务就只能排队等候。而如果这时候正好有用户操作了界面，例如点击文本框输入内容。用户就会真实的感受到卡顿

### 如何解决？

对于执行时间比较长的大任务，我们最常用的方式就是把它拆成若干个小任务来执行。React 开发团队也是这么搞的

一个执行时间比较长的大任务，它正常开始执行。当耗时达到 16.7 毫秒的时候（react 内部实现可能不是这个数字，这里仅用来解释概念），判断其是否已经执行完毕？

如果没有执行完毕，会查看是否有更重要的任务需要优先执行。如果有，则暂停之前的低优先级任务，优先执行优先级较高的任务。待高级优先级任务执行完成之后，再继续执行之前的低优先任务。依此类推

那哪些属于优先级比较高的任务呢？例如用户点击操作。用户期待的就是能够立刻接受到反馈，这些任务如果不优先尽快执行的话，用户立刻就会感受到界面的卡顿。而像网络请求等任务，哪怕稍微延迟一会儿，对用户的感知体验也不会有太大的影响

而为了实现这个机制，react 团队花了至少两年时间重写了其内部的任务调度算法



